package pl.bronikowski.springchat.backendmain.shared;

import jakarta.persistence.MappedSuperclass;
import org.hibernate.proxy.HibernateProxy;

import java.util.Objects;

@MappedSuperclass
public abstract class AbstractIdEqualsEntity<T> {
    protected abstract T getId();

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null) return false;
        if (getEffectiveClass(this) != getEffectiveClass(o)) return false;
        var that = (AbstractIdEqualsEntity<?>) o;
        return getId() != null && Objects.equals(getId(), that.getId());
    }

    // for jpa entity there should not be defined Set parameter with a lot of elements, so we can use one bucket
    // where complexity overhead is not visible
    // https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/
    // id cannot be used because it's generated by hibernate after persistence in most cases
    // if we can ensure existence of id from the beginning, method can be overridden
    @Override
    public int hashCode() {
        return getEffectiveClass(this).hashCode();
    }

    private Class<?> getEffectiveClass(Object o) {
        if (o instanceof HibernateProxy hibernateProxy) {
            return hibernateProxy.getHibernateLazyInitializer().getPersistentClass();
        }
        return o.getClass();
    }
}
